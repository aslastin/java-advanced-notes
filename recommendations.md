# Рекомендии по коду

## HW1

- Когда класс бросает исключение - необходимо подумтаь о том, будет ли он в валидном состоянии после обработки исключения пользователем.
- Если не удалось создать директории для `output file`, в который мы планируем записать - падать еще рано, можно упасть тогда, когда не получилось создать `Writer`.
- Переиспользуемое состояние (буфер с данными) лучше выносить в класс, чтобы избежать лишних аллокаций.
- *MessageDigest*:
  1. Не нужно каждый раз пересоздавать
  2. Не забывать сбрасывать его, если возникла ошибка при чтении/вычислении хэша. 
- Так же стоит сделать "ошибочный" хэш зависимым от алгоритма хэширования.
- По ошибкам должно быть понятно, на каком этапе программа упала и почему.
- Вместо `\n` использовать что-то более кросплатформенное.
- Все методы для работы с файлами желательно использовать из библиотеки `java.nio.file`.

## HW2

- Читайте документацию к реализуемому интерфейсу!
- Это есть в задании, но лучше повторю еще раз. Копипасту надо выносить! Даже если это пара строчек. Касается переиспользования конструкторов и многократного вызова  `Collections.binarySearch()`.
- Не стоит лишний раз писать самостоятельно то, что за вас уже написали  в стандартной библиотеке. Даже если вам кажется, что ваш код будет чуть быстрее.
- Если используете `ArrayList` для хранения данных, проверьте, что вашу коллекцию нельзя изменить через `iterator.remove()`.
- Не стоит пугаться **Unchecked cast**. Если программа реализована правильно, в паре случаев без него никак.
- `List.of()` предпочтительнее `Collections.emptyList()` - в современной java более модно писать так.
- Если хотите из `Collection<? extends E> coll` создать неизменяемый `List<E>`, то есть 2 подхода:
    1. Коллекции подерживает `null`: `Collections.unmodifiableList(new ArrayList<>(coll))`
    2. Коллекция не поддерживает `null`: `List.copyOf(coll)`


