# Collections

`+T` <-> `? extends T`
`-T` <-> `? super T`

`iterator.remove` - удаляет последний элемент, который вернули.

Коллекции не обязаны бросить `ConcurrentModificationException`.

Расширенный `for` работает и для массивов (проходится по массиву целиком).

В `.toArray` принято передавать либо массив нулевой длины, либо массив, который вместит все элементы. Элементы в результате вызова `.toArray` будут в порядке обхода итератора.

`UnsupportedOperationException` на практике бросается в изменяемых операциях.

`null instanceof T` -> всегда возвращает `false`.

`Set.of` кладет элементы в случайном порядке.

Если `Set.copyOf(коллекции, где есть null)` -> кинет `NullPointerExcepiton`.

`add(index, element)` - вставляет перед указанным индексом.

`List<E> subList(from, to) - from incl, to excl`

Бросить исключение - дорого, поймать - весьма дешево.

Очереди не обязаны гарантировать порядок на `peek` с обходом итератора (например, это не эффективно для упорядоченных множеств).

`keySet / entrySet` работают за O(1).

Под капотом `HashSet` лежит `HashMap`???

`Map.of` рандомизирует порядок.

Не надо полагаться, что `compareTo` возвращает -1 / 1 - просто какие-то отрицательные / положительные числа

Передаем `Comparator`, иначе подразумеваем, что реализует интерфейс `Comparable`, иначе валидно бросить `ClassCastException`.

Согласованность компараторов с `equals` нужна при перекладывании из одной коллекции в другую.

`Collections.reverse(list<?>)` учитывает интерфейс `RandomAccess`.

В `Enumeration` есть все то же самое, что и в `Iterator` - сделали из-за сокращения кода (на суффиксе был лишним Element)
